#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include <string.h>
#include <doslib.h>
#include "xdf.h"

// SECTOR 0: Boot Sector (0x000000 - 0x0003ff)
// ブートセクタ先頭 64 bytes  IPLは書き込まない
static uint8_t BOOT_SECTOR_HEADER[64] = {
  0x60,0x3c,0x90,0x58,0x36,0x38,0x49,0x50,0x4c,0x33,0x30,0x00,0x04,0x01,0x01,0x00,
  0x02,0xc0,0x00,0xd0,0x04,0xfe,0x02,0x00,0x08,0x00,0x02,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x20,0x20,0x20,
  0x20,0x20,0x20,0x20,0x20,0x20,0x46,0x41,0x54,0x31,0x32,0x20,0x20,0x20,0x00,0x00,
};

// SECTOR 1,2: FAT1 (0x000400 - 0x000bff)
// 先頭3バイトが 0xfe, 0xff, 0xff
// BPB_FatSz16 が 2なので 2クラスタ = 2セクタ = 2 * 1024 = 0x800 が FAT1つ分のサイズ
static uint8_t FAT1_HEADER[3] = { 0xfe, 0xff, 0xff };

// SECTOR 3,4: FAT2 (0x000c00 - 0x0013ff)
// 先頭3バイトが 0xfe, 0xff, 0xff
// BPB_NumFATs = 0x02 なので 二重化されていることになっているが、Human68kでは最初の2エントリしかない
static uint8_t FAT2_HEADER[3] = { 0xfe, 0xff, 0xff };

// 0x0013ff までで 1 + 4 セクタ = 5 * 1024 bytes = 5120 bytes = 0x001400 bytes

// SECTOR 5 - 10: Root Directory (0x001400 - 0x002bff)
// 0x002bff (11263) までルートディレクトリ 初期化時は 0x00 埋め
// 24 * 256 = 6 * 1024 = 6セクタ

// SECTOR 11 - 1231: Data Area (0x003c00 - 0x133fff)
// 0x133fff (1261567) まで 0xe5 埋め 1261567 - 11263 = 1250304 = 2442 * 512 = 1221 * 1024
// DataSectors = 1221
static uint8_t DATA_AREA_FILL[512] = {
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,

  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
  0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,0xe5,
};

int32_t xdf_init(XDF* xdf, const uint8_t* xdf_name) {

  int32_t rc = -1;

  strcpy(xdf->name, xdf_name);

  // ファイル新規オープン (存在チェックはここではしない)
  xdf->fp = fopen(xdf->name, "wb");
  if (xdf->fp == NULL) {
    printf("error: xdf file creation error. (%s)\n", xdf->name);
    goto exit;
  }

  // ブートセクタの先頭64bytesだけ書く
  fwrite(BOOT_SECTOR_HEADER, 1, 64, xdf->fp);

  // 一旦閉じる
  fclose(xdf->fp);

  // 再度ランダムアクセスオープン
  xdf->fp = fopen(xdf->name, "rb+");
  if (xdf->fp == NULL) {
    printf("error: xdf file random open error. (%s)\n", xdf->name);
    goto exit;
  }

  // 0x000400 - 0x000402 に 0xfe, 0xff, 0xff の3バイトが入る (後からFAT書き出す時にも書くけど念の為)
  // 0x000C00 - 0x000C02 に 0xfe, 0xff, 0xff の3バイトが入る (ここは実際には二重化されないのでここだけ)
  fseek(xdf->fp, 0x000400, SEEK_SET);
  fwrite(FAT1_HEADER, 1, 3, xdf->fp);
  fseek(xdf->fp, 0x000C00, SEEK_SET);
  fwrite(FAT2_HEADER, 1, 3, xdf->fp);

  // 0x002bff まで 0x00 埋め
  fseek(xdf->fp, 0x002c00, SEEK_SET);

  // 0x133fff まで 0xe5 埋め
  for (int16_t i = 0; i < 1221 * 2; i++) {
    fwrite(DATA_AREA_FILL, 1, 512, xdf->fp);
  }

  // ファイルクローズはせず開きっぱなし

  rc = 0;

exit:
  return rc;
}

void xdf_close(XDF* xdf) {
  if (xdf != NULL && xdf->fp != NULL) {
    fclose(xdf->fp);
    xdf->fp = NULL;
  }
}

int32_t xdf_read(XDF* xdf, int32_t sector, size_t len, uint8_t* buf) {
  fseek(xdf->fp, XDF_SECTOR_BYTES * sector, SEEK_SET);
  size_t total_len = XDF_SECTOR_BYTES * len;
  size_t read_len = 0;
  do {
    size_t len = fread(buf + read_len, sizeof(uint8_t), total_len - read_len, xdf->fp);
    if (len == 0) break;
    read_len += len;
  } while (read_len < total_len);
  return (read_len < total_len) ? -1 : 0;
}

int32_t xdf_write(XDF* xdf, int32_t sector, size_t len, uint8_t* buf) {
  fseek(xdf->fp, XDF_SECTOR_BYTES * sector, SEEK_SET);
  size_t total_len = XDF_SECTOR_BYTES * len;
  size_t write_len = 0;
  do {
    size_t len = fwrite(buf + write_len, sizeof(uint8_t), total_len - write_len, xdf->fp);
    if (len == 0) break;
    write_len += len;
  } while (write_len < total_len);
  return (write_len < total_len) ? -1 : 0;
}
